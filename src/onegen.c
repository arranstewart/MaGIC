/*				One.c
*
*	This uses RM (Read Matrices) to read ugly output from 
*	MaGIC and calls a function "g1" to choose those matrices
*	generated by a single element using only the connectives
*	present in the fragment, with the exception of the normal
*	sentential constants.  The one-generated matrices are
*	printed out.  The print format may be changed from the 
*	default (UGLY) to PRETTY or TeX by means of the command
*	line switches "-p" or "-t".
*
*	For details of the matrix structures and other goodies 
*	defined in the header, see RM.h.  The following should be
*	fairly self-explanatory, however.  Note that my_values and
*	my_string are optional extras used by printmat.  These are 
*	re-initialised to <-1,-1,-1,....> and "" by mat_malloc.
*	Use strcpy to put a message in m->my_string.
*
*	Function g1 finds all the elements whose singletons generate
*	the algebra, records them in my_values and returns 1 to print
*	the matrix or 0 to suppress printing.
*
*	Try is the recursive procedure for adding new elements
*	to the array got[].  It is beside the point if element
*	x has already been generated.
*
*	Command line option -u (ugly) is allowed but has no effect
*	since UGLY is the default print mode.
*/



	/****************************************************************
	*								*
	*			    MaGIC 2.1				*
	*								*
	*	    (C) 1993 Australian National University		*
	*								*
	* 		       All rights reserved			*
	*								*
	* The information in this software is subject to change without	*
	* notice and should not be construed as a commitment by the	*
	* Australian National University. The Australian National Uni-	*
	* versity makes no representations about the suitability of	*
	* this software for any purpose. It is supplied "as is" without	*
	* express or implied warranty.  If the software is modified in 	*
	* a manner creating derivative copyright rights, appropriate	*
	* legends may be placed on the derivative work in addition to	*
	* that set forth above.						*
	*								*
	* Permission to use, copy, modify and distribute this software	*
	* and its documentation for any purpose and without fee is	*
	* hereby granted, provided that both the above copyright notice	*
	* and this permission notice appear in all copies and sup-	*
	* porting documentation, and that the name of the Australian	*
	* National University not be used in advertising or publicity	*
	* pertaining to distribution of the software without specific,	*
	* written prior permission.					*
	*								*
	****************************************************************/



#include "RM.h"


static int tot_got;		/* Total of elements generated	*/
static int got[SZ];		/* Elements generated so far	*/



int main( argc, argv )
int argc;
char *argv[];
{
  int option;
  PRINTMODE p = UGLY;
  int g1();
  int getopt();

  while ((option = getopt (argc, argv, "upt")) != -1)
    switch( option ) {
    case 'p': p = PRETTY;	break;
    case 't': p = TeX;
    }
  selectmats( g1, p );
  return 0;
}




int g1(m)
MATRIX *m;
{
  int i;
  int generator;
  int position = 0;
  void try();

  FORALL(m,generator) {
    FORALL(m,i) got[i] = 0;
    tot_got = 0;
    FORALLCON(m,i)
      if ( m->adicity[i] == 0 ) try( m, m->nulladic[i] );
    try( m, generator );
    if ( tot_got > m->siz ) {
      m->my_values[position] = generator;
      if ( position++ )
	strcpy( m->my_string, "Possible generators: ");
      else strcpy( m->my_string, "Generator: ");
    }
  }
  return( position > 0 );
}





void try(m,x)
MATRIX *m;
int x;
{
  int i, j;

  if ( got[x] ) return;

  got[x] = 1;
  tot_got++;
  if ( m->fragment[NEG] ) try( m, m->neg[x] );
  if ( m->fragment[BOX] ) try( m, m->box[x] );
  FORALLCON(m,i)
    if ( m->adicity[i] == 1 ) try( m, m->monadic[i][x] );
  FORALL(m,i) if ( got[i] ) {
    try( m, m->C[i][x] );
    try( m, m->C[x][i] );
    if ( m->fragment[LAT] ) {
      try( m, m->K[i][x] );
      try( m, m->A[i][x] );
    }
    if ( m->fragment[FUS] ) {
      try( m, m->fus[i][x] );
      try( m, m->fus[x][i] );
    }
    FORALLCON(m,j) {
      if ( m->adicity[j] == 2 )
	try( m, m->dyadic[j][i][x] );
      try( m, m->dyadic[j][x][i] );
    }
  }
}
